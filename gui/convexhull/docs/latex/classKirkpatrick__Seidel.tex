\hypertarget{classKirkpatrick__Seidel}{}\doxysection{Kirkpatrick\+\_\+\+Seidel Class Reference}
\label{classKirkpatrick__Seidel}\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
Inheritance diagram for Kirkpatrick\+\_\+\+Seidel\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classKirkpatrick__Seidel}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classKirkpatrick__Seidel_a7201eced0c9edc442fdca2dcab3a1b6d}\label{classKirkpatrick__Seidel_a7201eced0c9edc442fdca2dcab3a1b6d}} 
{\bfseries Kirkpatrick\+\_\+\+Seidel} (vector$<$ struct \mbox{\hyperlink{structpoint}{point}} $>$ points, \mbox{\hyperlink{classMainWindow}{Main\+Window}} $\ast$w)
\item 
void \mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\+\_\+point}} (int idx)
\item 
void \mbox{\hyperlink{classKirkpatrick__Seidel_a27411b5aba77fbca38854e6032c2ac33}{print\+\_\+pairs\+\_\+on\+\_\+hull}} ()
\item 
void \mbox{\hyperlink{classKirkpatrick__Seidel_a87772fab208930356384e5c568ecee69}{put\+\_\+a\+\_\+hull\+\_\+on\+\_\+points}} ()
\item 
void \mbox{\hyperlink{classKirkpatrick__Seidel_a3580c52f1f0cf27589ce8fa39f7af669}{draw\+\_\+bridge}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classKirkpatrick__Seidel_af27c76b65420d9e4f9fbc96c5d20b38f}\label{classKirkpatrick__Seidel_af27c76b65420d9e4f9fbc96c5d20b38f}} 
\mbox{\hyperlink{classMainWindow}{Main\+Window}} $\ast$ {\bfseries w}
\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classKirkpatrick__Seidel_a52003531d137b726b20e51ca614e40b7}{get\+\_\+extremum\+\_\+points}} ()
\item 
double \mbox{\hyperlink{classKirkpatrick__Seidel_a180f5fcebe4744b99ee618066b819764}{calculate\+\_\+p2p\+\_\+slope}} (int idx1, int idx2)
\item 
vector$<$ int $>$ \mbox{\hyperlink{classKirkpatrick__Seidel_a3469702d1b4f11eb2d52d8bd29a9f3a8}{get\+\_\+candidates\+\_\+idx}} (unsigned int cur\+\_\+pu\+\_\+min\+\_\+idx, unsigned int cur\+\_\+pu\+\_\+max\+\_\+idx)
\item 
struct \mbox{\hyperlink{structp2p__slope}{p2p\+\_\+slope}} $\ast$ \mbox{\hyperlink{classKirkpatrick__Seidel_a489b1cbb1985e231f1ae41c7128adc1c}{get\+\_\+p2p\+\_\+slope\+\_\+entry}} (int idx1, int idx2, double slope)
\item 
vector$<$ \mbox{\hyperlink{structp2p__slope}{p2p\+\_\+slope}} $\ast$ $>$ \mbox{\hyperlink{classKirkpatrick__Seidel_a403fd3696ad1a6b7dedb75cb8f5eaab7}{get\+\_\+pair\+\_\+slopes}} (vector$<$ int $>$ \&cand\+\_\+idx, vector$<$ int $>$ \&new\+\_\+cand\+\_\+idx)
\item 
\mbox{\Hypertarget{classKirkpatrick__Seidel_afa21506d3cd0d121b337145af844191a}\label{classKirkpatrick__Seidel_afa21506d3cd0d121b337145af844191a}} 
int {\bfseries fill\+\_\+slope\+\_\+bucket} (vector$<$ struct \mbox{\hyperlink{structp2p__slope}{p2p\+\_\+slope}} $\ast$ $>$ \&pair\+\_\+slopes, vector$<$ int $>$ \&L\+A\+R\+G\+E\+\_\+\+S\+L\+O\+PE, vector$<$ int $>$ \&E\+Q\+U\+A\+L\+\_\+\+S\+L\+O\+PE, vector$<$ int $>$ \&S\+M\+A\+L\+L\+\_\+\+S\+L\+O\+PE)
\item 
void \mbox{\hyperlink{classKirkpatrick__Seidel_ab93d5d2d8b237254490a31a48479489c}{generate\+\_\+new\+\_\+cand\+\_\+idx}} (int leave\+\_\+flag, vector$<$ int $>$ \&new\+\_\+cand\+\_\+idx, vector$<$ struct \mbox{\hyperlink{structp2p__slope}{p2p\+\_\+slope}} $\ast$ $>$ \&pair\+\_\+slopes, vector$<$ int $>$ \&L\+A\+R\+G\+E\+\_\+\+S\+L\+O\+PE, vector$<$ int $>$ \&E\+Q\+U\+A\+L\+\_\+\+S\+L\+O\+PE, vector$<$ int $>$ \&S\+M\+A\+L\+L\+\_\+\+S\+L\+O\+PE)
\item 
vector$<$ int $>$ \mbox{\hyperlink{classKirkpatrick__Seidel_a88715575474aaae15641eb578e94933d}{get\+\_\+bridge\+\_\+or\+\_\+candidate}} (double med\+\_\+x, int med\+\_\+slope\+\_\+idx, vector$<$ int $>$ \&cand\+\_\+idx, vector$<$ int $>$ \&new\+\_\+cand\+\_\+idx, vector$<$ struct \mbox{\hyperlink{structp2p__slope}{p2p\+\_\+slope}} $\ast$ $>$ \&pair\+\_\+slopes, vector$<$ int $>$ \&L\+A\+R\+G\+E\+\_\+\+S\+L\+O\+PE, vector$<$ int $>$ \&E\+Q\+U\+A\+L\+\_\+\+S\+L\+O\+PE, vector$<$ int $>$ \&S\+M\+A\+L\+L\+\_\+\+S\+L\+O\+PE)
\item 
vector$<$ int $>$ \mbox{\hyperlink{classKirkpatrick__Seidel_a5186a9dd5060b8243cf455c7faf9fb92}{get\+\_\+upper\+\_\+bridge}} (double med\+\_\+x, vector$<$ int $>$ \&cand\+\_\+idx)
\item 
void \mbox{\hyperlink{classKirkpatrick__Seidel_ad4364483a9ba0f48498d010ff7b16590}{append\+\_\+bridge\+\_\+point\+\_\+to\+\_\+hull}} (vector$<$ int $>$ \&bridge\+\_\+idx)
\item 
void \mbox{\hyperlink{classKirkpatrick__Seidel_a354a7cd71efe24b6750744b993ad48f5}{get\+\_\+upper\+\_\+hull}} (vector$<$ int $>$ \&cand\+\_\+idx, unsigned int min\+\_\+x\+\_\+idx, unsigned int max\+\_\+x\+\_\+idx)
\item 
void \mbox{\hyperlink{classKirkpatrick__Seidel_a766a0a811f34a933a6c53125df5ee1d7}{transform\+\_\+lowers\+\_\+to\+\_\+upper}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classKirkpatrick__Seidel_ab675b73dec523464e1610ffae38b07de}\label{classKirkpatrick__Seidel_ab675b73dec523464e1610ffae38b07de}} 
unsigned int {\bfseries pu\+\_\+min\+\_\+idx}
\item 
\mbox{\Hypertarget{classKirkpatrick__Seidel_ab4d31709deb9004944edccf3ab00c4c2}\label{classKirkpatrick__Seidel_ab4d31709deb9004944edccf3ab00c4c2}} 
unsigned int {\bfseries pu\+\_\+max\+\_\+idx}
\item 
\mbox{\Hypertarget{classKirkpatrick__Seidel_a44f64427d2bc97a7eef17e189acac45c}\label{classKirkpatrick__Seidel_a44f64427d2bc97a7eef17e189acac45c}} 
unsigned int {\bfseries pl\+\_\+min\+\_\+idx}
\item 
\mbox{\Hypertarget{classKirkpatrick__Seidel_a1c1cf20019f924939130d8af19e077e5}\label{classKirkpatrick__Seidel_a1c1cf20019f924939130d8af19e077e5}} 
unsigned int {\bfseries pl\+\_\+max\+\_\+idx}
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}


Definition at line 8 of file kirkpatrick\+\_\+seidel.\+h.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classKirkpatrick__Seidel_ad4364483a9ba0f48498d010ff7b16590}\label{classKirkpatrick__Seidel_ad4364483a9ba0f48498d010ff7b16590}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!append\_bridge\_point\_to\_hull@{append\_bridge\_point\_to\_hull}}
\index{append\_bridge\_point\_to\_hull@{append\_bridge\_point\_to\_hull}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{append\_bridge\_point\_to\_hull()}{append\_bridge\_point\_to\_hull()}}
{\footnotesize\ttfamily void Kirkpatrick\+\_\+\+Seidel\+::append\+\_\+bridge\+\_\+point\+\_\+to\+\_\+hull (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{bridge\+\_\+idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This function will append the bridge points pair found out by the upper bridge method to the hull points. This will not add if the pair already exist on hull.

Also this will display the bridge line on the G\+UI window.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em bridge\+\_\+idx} & \+: the vecotr containing the index of bridge\\
\hline
\end{DoxyParams}


Definition at line 740 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{741                                                             \{}
\DoxyCodeLine{751     \textcolor{comment}{//Making the pair of the points on the convex hull sorted}}
\DoxyCodeLine{752     pair<int,int> hull\_pair=make\_pair(bridge\_idx[0],bridge\_idx[1]);}
\DoxyCodeLine{753     \textcolor{comment}{//Checking the existance of the pair on hull}}
\DoxyCodeLine{754     \textcolor{comment}{//This should not happen i.e one pair should only come}}
\DoxyCodeLine{755     \textcolor{comment}{//one time as the bridge.}}
\DoxyCodeLine{756     \textcolor{keywordtype}{bool} exist=find(hull\_point\_pairs.begin(),hull\_point\_pairs.end(),\(\backslash\)}
\DoxyCodeLine{757                     hull\_pair)!=hull\_point\_pairs.end();}
\DoxyCodeLine{758     \textcolor{keywordflow}{if}(exist)\{}
\DoxyCodeLine{759         cout<<\textcolor{stringliteral}{"Pair already exist. Some mistake is there\(\backslash\)n"};}
\DoxyCodeLine{760         exit(0);}
\DoxyCodeLine{761     \}}
\DoxyCodeLine{762     cout<<\textcolor{stringliteral}{"Appending the bridge point to the hull points\(\backslash\)n"};}
\DoxyCodeLine{763     hull\_point\_pairs.push\_back(hull\_pair);}
\DoxyCodeLine{764 }
\DoxyCodeLine{765 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a180f5fcebe4744b99ee618066b819764}\label{classKirkpatrick__Seidel_a180f5fcebe4744b99ee618066b819764}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!calculate\_p2p\_slope@{calculate\_p2p\_slope}}
\index{calculate\_p2p\_slope@{calculate\_p2p\_slope}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{calculate\_p2p\_slope()}{calculate\_p2p\_slope()}}
{\footnotesize\ttfamily double Kirkpatrick\+\_\+\+Seidel\+::calculate\+\_\+p2p\+\_\+slope (\begin{DoxyParamCaption}\item[{int}]{idx1,  }\item[{int}]{idx2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This function will calcualte the slope from the x-\/axis from the line made by the points at idx1 and idx2; 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em idx1} & \+: the index of the first point \\
\hline
\mbox{\texttt{ in}}  & {\em idx2} & \+: the index of the second point\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
slope \+:the slope of the line connecting idx1 nad idx2
\end{DoxyReturn}


Definition at line 236 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{236                                                                \{}
\DoxyCodeLine{245     \textcolor{keywordtype}{double} slope=(double)(points[idx2].y-\/points[idx1].y)/\(\backslash\)}
\DoxyCodeLine{246                 (double)(points[idx2].x-\/points[idx1].x);}
\DoxyCodeLine{247     \textcolor{keywordflow}{return} slope;}
\DoxyCodeLine{248 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a3580c52f1f0cf27589ce8fa39f7af669}\label{classKirkpatrick__Seidel_a3580c52f1f0cf27589ce8fa39f7af669}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!draw\_bridge@{draw\_bridge}}
\index{draw\_bridge@{draw\_bridge}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{draw\_bridge()}{draw\_bridge()}}
{\footnotesize\ttfamily void Kirkpatrick\+\_\+\+Seidel\+::draw\+\_\+bridge (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

This fucntion will draw the lines on the hull in the order they were generated by the kirkpatrick siedel algorithm.

This is the only place where the gui object reference is used.

Definition at line 138 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{138                                     \{}
\DoxyCodeLine{145     \textcolor{comment}{//Displaying this bridge on the gui using the reference of the window}}
\DoxyCodeLine{146     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<this-\/>hull\_point\_pairs.size();i++)\{}
\DoxyCodeLine{147         \textcolor{comment}{//Getting the index}}
\DoxyCodeLine{148         \textcolor{keywordtype}{int} idx1=this-\/>hull\_point\_pairs[i].first;}
\DoxyCodeLine{149         \textcolor{keywordtype}{int} idx2=this-\/>hull\_point\_pairs[i].second;}
\DoxyCodeLine{150 }
\DoxyCodeLine{151         \textcolor{comment}{//Creating the vector of points}}
\DoxyCodeLine{152         vector<struct point> display\_points;}
\DoxyCodeLine{153         \textcolor{keyword}{struct }\mbox{\hyperlink{structpoint}{point}} p1,p2;}
\DoxyCodeLine{154         \textcolor{comment}{//Copying the location of point on these local copy}}
\DoxyCodeLine{155         p1=this-\/>points[idx1];}
\DoxyCodeLine{156         p2=this-\/>points[idx2];}
\DoxyCodeLine{157         \textcolor{comment}{//Pushing these points on the vector}}
\DoxyCodeLine{158         display\_points.push\_back(p1);}
\DoxyCodeLine{159         display\_points.push\_back(p2);}
\DoxyCodeLine{160         \textcolor{comment}{//Calling the display function to draw these line on gui}}
\DoxyCodeLine{161         this-\/>w-\/>drawLines(display\_points);}
\DoxyCodeLine{162         sleep(1);}
\DoxyCodeLine{163     \}}
\DoxyCodeLine{164 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_ab93d5d2d8b237254490a31a48479489c}\label{classKirkpatrick__Seidel_ab93d5d2d8b237254490a31a48479489c}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!generate\_new\_cand\_idx@{generate\_new\_cand\_idx}}
\index{generate\_new\_cand\_idx@{generate\_new\_cand\_idx}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{generate\_new\_cand\_idx()}{generate\_new\_cand\_idx()}}
{\footnotesize\ttfamily void Kirkpatrick\+\_\+\+Seidel\+::generate\+\_\+new\+\_\+cand\+\_\+idx (\begin{DoxyParamCaption}\item[{int}]{leave\+\_\+flag,  }\item[{vector$<$ int $>$ \&}]{new\+\_\+cand\+\_\+idx,  }\item[{vector$<$ struct \mbox{\hyperlink{structp2p__slope}{p2p\+\_\+slope}} $\ast$ $>$ \&}]{pair\+\_\+slopes,  }\item[{vector$<$ int $>$ \&}]{L\+A\+R\+G\+E\+\_\+\+S\+L\+O\+PE,  }\item[{vector$<$ int $>$ \&}]{E\+Q\+U\+A\+L\+\_\+\+S\+L\+O\+PE,  }\item[{vector$<$ int $>$ \&}]{S\+M\+A\+L\+L\+\_\+\+S\+L\+O\+PE }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This function will generate the new candidate points leaving 1/4th of them either from the L\+A\+R\+GE or from S\+M\+A\+LL S\+L\+O\+PE indexes based on the the condition mentioned int leave\+\_\+flag.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em leave\+\_\+flag} & \+: 0/1 -\/ if 0 then remove p from L\+A\+R\+GE if 1 then remove q from the S\+M\+A\+LL of the (p,q) sorted pair. \\
\hline
\mbox{\texttt{ out}}  & {\em new\+\_\+cand\+\_\+idx} & the vector which contain the idx of new cand \\
\hline
\mbox{\texttt{ in}}  & {\em pair\+\_\+slopes} & \+: the vector containg the slopes of each pair \\
\hline
\mbox{\texttt{ in}}  & {\em L\+A\+R\+G\+E\+\_\+\+S\+L\+O\+PE} & \+: the index of pairs with large slope \\
\hline
\mbox{\texttt{ in}}  & {\em E\+Q\+U\+A\+L\+\_\+\+S\+L\+O\+PE} & \+: the index of pairs with equal slope to med \\
\hline
\mbox{\texttt{ in}}  & {\em S\+M\+A\+L\+L\+\_\+\+S\+L\+O\+PE} & \+: the index of pairs with smallar slope\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new\+\_\+cand\+\_\+idx\+: the list will be filled with the new candidate points for the next itr.
\end{DoxyReturn}


Definition at line 439 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{444                                                              \{}
\DoxyCodeLine{463     \textcolor{keywordflow}{if}(leave\_flag!=0 \&\& leave\_flag!=1)\{}
\DoxyCodeLine{464         cout<<\textcolor{stringliteral}{"Wrong leave flag\(\backslash\)n"};}
\DoxyCodeLine{465         exit(0);}
\DoxyCodeLine{466     \}}
\DoxyCodeLine{467     cout<<\textcolor{stringliteral}{"Generating the new pruned candidates\(\backslash\)n"};}
\DoxyCodeLine{468     \textcolor{keywordflow}{if}(leave\_flag==0)\{}
\DoxyCodeLine{469         cout<<\textcolor{stringliteral}{"CODE mh>mb : "}<<endl;}
\DoxyCodeLine{470         cout<<\textcolor{stringliteral}{"Removing the p point of (p,q) pair from LARGE\(\backslash\)n"};}
\DoxyCodeLine{471         \textcolor{comment}{//Remove the p from the LARGE slope ones}}
\DoxyCodeLine{472         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<LARGE\_SLOPE.size();i++)\{}
\DoxyCodeLine{473             \textcolor{keyword}{struct }\mbox{\hyperlink{structp2p__slope}{p2p\_slope}} *ptr=pair\_slopes[LARGE\_SLOPE[i]];}
\DoxyCodeLine{474             \textcolor{keywordflow}{if}(points[ptr-\/>idx1].x<points[ptr-\/>idx2].x)\{}
\DoxyCodeLine{475                 cout<<\textcolor{stringliteral}{"Adding idx: "}<<ptr-\/>idx2<<endl;}
\DoxyCodeLine{476                 new\_cand\_idx.push\_back(ptr-\/>idx2);}
\DoxyCodeLine{477             \}}
\DoxyCodeLine{478             \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{479                 cout<<\textcolor{stringliteral}{"Adding idx: "}<<ptr-\/>idx1<<endl;}
\DoxyCodeLine{480                 new\_cand\_idx.push\_back(ptr-\/>idx1);}
\DoxyCodeLine{481             \}}
\DoxyCodeLine{482         \}}
\DoxyCodeLine{483         cout<<\textcolor{stringliteral}{"Removing the p point of (p,q) pair from EQUAL\(\backslash\)n"};}
\DoxyCodeLine{484         \textcolor{comment}{//Removing p from the Equal also}}
\DoxyCodeLine{485         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<EQUAL\_SLOPE.size();i++)\{}
\DoxyCodeLine{486             \textcolor{keyword}{struct }\mbox{\hyperlink{structp2p__slope}{p2p\_slope}} *ptr=pair\_slopes[EQUAL\_SLOPE[i]];}
\DoxyCodeLine{487             \textcolor{keywordflow}{if}(points[ptr-\/>idx1].x<points[ptr-\/>idx2].x)\{}
\DoxyCodeLine{488                 cout<<\textcolor{stringliteral}{"Adding idx: "}<<ptr-\/>idx2<<endl;}
\DoxyCodeLine{489                 new\_cand\_idx.push\_back(ptr-\/>idx2);}
\DoxyCodeLine{490             \}}
\DoxyCodeLine{491             \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{492                 cout<<\textcolor{stringliteral}{"Adding idx: "}<<ptr-\/>idx1<<endl;}
\DoxyCodeLine{493                 new\_cand\_idx.push\_back(ptr-\/>idx1);}
\DoxyCodeLine{494             \}}
\DoxyCodeLine{495         \}}
\DoxyCodeLine{496         cout<<\textcolor{stringliteral}{"Adding all point of (p,q) pair from SMALL\(\backslash\)n"};}
\DoxyCodeLine{497         \textcolor{comment}{//Adding all of the SMALL ones}}
\DoxyCodeLine{498         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<SMALL\_SLOPE.size();i++)\{}
\DoxyCodeLine{499             \textcolor{keyword}{struct }\mbox{\hyperlink{structp2p__slope}{p2p\_slope}} *ptr=pair\_slopes[SMALL\_SLOPE[i]];}
\DoxyCodeLine{500             new\_cand\_idx.push\_back(ptr-\/>idx1);}
\DoxyCodeLine{501             new\_cand\_idx.push\_back(ptr-\/>idx2);}
\DoxyCodeLine{502         \}}
\DoxyCodeLine{503     \}}
\DoxyCodeLine{504     \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{505         cout<<\textcolor{stringliteral}{"CODE mh<mb : "}<<endl;}
\DoxyCodeLine{506         cout<<\textcolor{stringliteral}{"Removing the p point of (p,q) pair from SMALL\(\backslash\)n"};}
\DoxyCodeLine{507         \textcolor{comment}{//Removing q from the SMALL}}
\DoxyCodeLine{508         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<SMALL\_SLOPE.size();i++)\{}
\DoxyCodeLine{509             \textcolor{keyword}{struct }\mbox{\hyperlink{structp2p__slope}{p2p\_slope}} *ptr=pair\_slopes[SMALL\_SLOPE[i]];}
\DoxyCodeLine{510             \textcolor{keywordflow}{if}(points[ptr-\/>idx1].x<points[ptr-\/>idx2].x)\{}
\DoxyCodeLine{511                 cout<<\textcolor{stringliteral}{"Adding idx: "}<<ptr-\/>idx1<<endl;}
\DoxyCodeLine{512                 new\_cand\_idx.push\_back(ptr-\/>idx1);}
\DoxyCodeLine{513             \}}
\DoxyCodeLine{514             \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{515                 cout<<\textcolor{stringliteral}{"Adding idx: "}<<ptr-\/>idx2<<endl;}
\DoxyCodeLine{516                 new\_cand\_idx.push\_back(ptr-\/>idx2);}
\DoxyCodeLine{517             \}}
\DoxyCodeLine{518         \}}
\DoxyCodeLine{519         cout<<\textcolor{stringliteral}{"Removing the p point of (p,q) pair from EQUAL\(\backslash\)n"};}
\DoxyCodeLine{520         \textcolor{comment}{//Removing q from EQUAL also}}
\DoxyCodeLine{521         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<EQUAL\_SLOPE.size();i++)\{}
\DoxyCodeLine{522             \textcolor{keyword}{struct }\mbox{\hyperlink{structp2p__slope}{p2p\_slope}} *ptr=pair\_slopes[EQUAL\_SLOPE[i]];}
\DoxyCodeLine{523             \textcolor{keywordflow}{if}(points[ptr-\/>idx1].x<points[ptr-\/>idx2].x)\{}
\DoxyCodeLine{524                 cout<<\textcolor{stringliteral}{"Adding idx: "}<<ptr-\/>idx1<<endl;}
\DoxyCodeLine{525                 new\_cand\_idx.push\_back(ptr-\/>idx1);}
\DoxyCodeLine{526             \}}
\DoxyCodeLine{527             \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{528                 cout<<\textcolor{stringliteral}{"Adding idx: "}<<ptr-\/>idx2<<endl;}
\DoxyCodeLine{529                 new\_cand\_idx.push\_back(ptr-\/>idx2);}
\DoxyCodeLine{530             \}}
\DoxyCodeLine{531         \}}
\DoxyCodeLine{532         cout<<\textcolor{stringliteral}{"Adding all point of (p,q) pair from LARGE\(\backslash\)n"};}
\DoxyCodeLine{533         \textcolor{comment}{//Adding all of the LARGE}}
\DoxyCodeLine{534         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<LARGE\_SLOPE.size();i++)\{}
\DoxyCodeLine{535             \textcolor{keyword}{struct }\mbox{\hyperlink{structp2p__slope}{p2p\_slope}} *ptr=pair\_slopes[LARGE\_SLOPE[i]];}
\DoxyCodeLine{536             new\_cand\_idx.push\_back(ptr-\/>idx1);}
\DoxyCodeLine{537             new\_cand\_idx.push\_back(ptr-\/>idx2);}
\DoxyCodeLine{538         \}}
\DoxyCodeLine{539 }
\DoxyCodeLine{540     \}}
\DoxyCodeLine{541 }
\DoxyCodeLine{542     \textcolor{comment}{//Printing all the points in new cand\_idx:}}
\DoxyCodeLine{543     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<new\_cand\_idx.size();i++)\{}
\DoxyCodeLine{544         cout<<\textcolor{stringliteral}{"new UH-\/Cand: "};}
\DoxyCodeLine{545         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(new\_cand\_idx[i]);}
\DoxyCodeLine{546     \}}
\DoxyCodeLine{547 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a88715575474aaae15641eb578e94933d}\label{classKirkpatrick__Seidel_a88715575474aaae15641eb578e94933d}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!get\_bridge\_or\_candidate@{get\_bridge\_or\_candidate}}
\index{get\_bridge\_or\_candidate@{get\_bridge\_or\_candidate}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{get\_bridge\_or\_candidate()}{get\_bridge\_or\_candidate()}}
{\footnotesize\ttfamily vector$<$ int $>$ Kirkpatrick\+\_\+\+Seidel\+::get\+\_\+bridge\+\_\+or\+\_\+candidate (\begin{DoxyParamCaption}\item[{double}]{med\+\_\+x,  }\item[{int}]{med\+\_\+slope\+\_\+idx,  }\item[{vector$<$ int $>$ \&}]{cand\+\_\+idx,  }\item[{vector$<$ int $>$ \&}]{new\+\_\+cand\+\_\+idx,  }\item[{vector$<$ struct \mbox{\hyperlink{structp2p__slope}{p2p\+\_\+slope}} $\ast$ $>$ \&}]{pair\+\_\+slopes,  }\item[{vector$<$ int $>$ \&}]{L\+A\+R\+G\+E\+\_\+\+S\+L\+O\+PE,  }\item[{vector$<$ int $>$ \&}]{E\+Q\+U\+A\+L\+\_\+\+S\+L\+O\+PE,  }\item[{vector$<$ int $>$ \&}]{S\+M\+A\+L\+L\+\_\+\+S\+L\+O\+PE }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This function will find a supporting line with median slope and check if two points on the opposite side of median point lies on that line(if one on line we will use as bridge). Then return the index of both the point in the vector

Otherwise make a reduced set of new\+\_\+cand\+\_\+idx and return empty vector to indicate applying recursion.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em med\+\_\+x} & \+: the x-\/coordinate of the median point \\
\hline
\mbox{\texttt{ in}}  & {\em med\+\_\+slope\+\_\+idx} & \+: the index of pair with med slope \\
\hline
\mbox{\texttt{ in}}  & {\em cand\+\_\+idx} & \+: the index of the current candidates \\
\hline
\mbox{\texttt{ out}}  & {\em new\+\_\+cand\+\_\+idx} & the vector which contain the idx of new cand \\
\hline
\mbox{\texttt{ in}}  & {\em pair\+\_\+slopes} & \+: the vector containg the slopes of each pair \\
\hline
\mbox{\texttt{ in}}  & {\em L\+A\+R\+G\+E\+\_\+\+S\+L\+O\+PE} & \+: the index of pairs with large slope \\
\hline
\mbox{\texttt{ in}}  & {\em E\+Q\+U\+A\+L\+\_\+\+S\+L\+O\+PE} & \+: the index of pairs with equal slope to med \\
\hline
\mbox{\texttt{ in}}  & {\em S\+M\+A\+L\+L\+\_\+\+S\+L\+O\+PE} & \+: the index of pairs with smallar slope\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bridge\+\_\+point\+\_\+idx\+: the vector of index of our bridge if it\textquotesingle{}s possible in sorted order with x-\/coordinate.
\end{DoxyReturn}


Definition at line 549 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{556                                                              \{}
\DoxyCodeLine{579     \textcolor{comment}{//Retreiving the median slope}}
\DoxyCodeLine{580     \textcolor{keywordtype}{double} med\_slope=pair\_slopes[med\_slope\_idx]-\/>slope;}
\DoxyCodeLine{581 }
\DoxyCodeLine{582     \textcolor{comment}{//Getting the maximum y-\/intercept possible with median slope}}
\DoxyCodeLine{583     cout<<\textcolor{stringliteral}{"\(\backslash\)nFinding the maximum intercept"}<<endl;}
\DoxyCodeLine{584     \textcolor{keywordtype}{double} max\_intrcpt;}
\DoxyCodeLine{585     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<cand\_idx.size();i++)\{}
\DoxyCodeLine{586         \textcolor{keywordtype}{double} intrcpt=(double)points[cand\_idx[i]].y-\/\(\backslash\)}
\DoxyCodeLine{587                             med\_slope*(\textcolor{keywordtype}{double})points[cand\_idx[i]].x;}
\DoxyCodeLine{588         \textcolor{keywordflow}{if}(i==0)\{}
\DoxyCodeLine{589             max\_intrcpt=intrcpt;}
\DoxyCodeLine{590         \}}
\DoxyCodeLine{591         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(intrcpt>max\_intrcpt)\{}
\DoxyCodeLine{592             max\_intrcpt=intrcpt;}
\DoxyCodeLine{593         \}}
\DoxyCodeLine{594     \}}
\DoxyCodeLine{595     cout<<\textcolor{stringliteral}{"Maximum intercept is: "}<<max\_intrcpt<<endl<<endl;}
\DoxyCodeLine{596 }
\DoxyCodeLine{597 }
\DoxyCodeLine{598     \textcolor{comment}{//Now getting the point with MAX intercept}}
\DoxyCodeLine{599     cout<<\textcolor{stringliteral}{"Finding the points which makes that intercept"};}
\DoxyCodeLine{600     cout<<\textcolor{stringliteral}{" i.e lies on this supporting line"}<<endl;}
\DoxyCodeLine{601     vector<int> MAX;}
\DoxyCodeLine{602     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<cand\_idx.size();i++)\{}
\DoxyCodeLine{603         \textcolor{keywordtype}{double} intrcpt=(double)points[cand\_idx[i]].y-\/\(\backslash\)}
\DoxyCodeLine{604                         med\_slope*(\textcolor{keywordtype}{double})points[cand\_idx[i]].x;}
\DoxyCodeLine{605 }
\DoxyCodeLine{606         \textcolor{comment}{//Here due to machine precision we could have problem}}
\DoxyCodeLine{607         \textcolor{comment}{//alternatively we could add tolerance here.}}
\DoxyCodeLine{608         \textcolor{keywordtype}{double} tolerance=0.000001;}
\DoxyCodeLine{609         \textcolor{keywordflow}{if}((intrcpt>max\_intrcpt \&\& intrcpt-\/max\_intrcpt<tolerance)}
\DoxyCodeLine{610             || (intrcpt<max\_intrcpt \&\& max\_intrcpt-\/intrcpt<tolerance)}
\DoxyCodeLine{611             || intrcpt==max\_intrcpt)\{}
\DoxyCodeLine{612             cout<<\textcolor{stringliteral}{"id of points lying on this support: "}<<cand\_idx[i];}
\DoxyCodeLine{613             cout<<endl;}
\DoxyCodeLine{614             MAX.push\_back(cand\_idx[i]);}
\DoxyCodeLine{615         \}}
\DoxyCodeLine{616     \}}
\DoxyCodeLine{617     cout<<endl;}
\DoxyCodeLine{618     \textcolor{comment}{//Now seeing x-\/coordinate of points on this line}}
\DoxyCodeLine{619     cout<<\textcolor{stringliteral}{"Finding the min and max x of points lying on support\(\backslash\)n"};}
\DoxyCodeLine{620     \textcolor{keywordtype}{double} min\_x=points[MAX[0]].x;\textcolor{keywordtype}{int} min\_idx=MAX[0];}
\DoxyCodeLine{621     \textcolor{keywordtype}{double} max\_x=points[MAX[0]].x;\textcolor{keywordtype}{int} max\_idx=MAX[0];}
\DoxyCodeLine{622     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=1;i<MAX.size();i++)\{}
\DoxyCodeLine{623         \textcolor{keywordflow}{if}(points[MAX[i]].x<min\_x)\{}
\DoxyCodeLine{624             min\_x=points[MAX[i]].x;}
\DoxyCodeLine{625             min\_idx=MAX[i];}
\DoxyCodeLine{626         \}}
\DoxyCodeLine{627         \textcolor{keywordflow}{if}(points[MAX[i]].x>max\_x)\{}
\DoxyCodeLine{628             max\_x=points[MAX[i]].x;}
\DoxyCodeLine{629             max\_idx=MAX[i];}
\DoxyCodeLine{630         \}}
\DoxyCodeLine{631     \}}
\DoxyCodeLine{632     cout<<\textcolor{stringliteral}{"max idx: "}<<max\_idx<<\textcolor{stringliteral}{" max\_x: "}<<max\_x<<endl;}
\DoxyCodeLine{633     cout<<\textcolor{stringliteral}{"min idx: "}<<min\_idx<<\textcolor{stringliteral}{" min\_x: "}<<min\_x<<endl<<endl;}
\DoxyCodeLine{634 }
\DoxyCodeLine{635 }
\DoxyCodeLine{636     \textcolor{comment}{//Now seeing if we have landed on the jackpot bridge points}}
\DoxyCodeLine{637     vector<int> bridge\_point\_idx;}
\DoxyCodeLine{638     \textcolor{keywordflow}{if}(min\_x<=med\_x \&\& max\_x>med\_x)\{}
\DoxyCodeLine{639         cout<<\textcolor{stringliteral}{"Jackpot! Got a Bridge Line!!"}<<endl;}
\DoxyCodeLine{640         bridge\_point\_idx.push\_back(min\_idx);}
\DoxyCodeLine{641         bridge\_point\_idx.push\_back(max\_idx);}
\DoxyCodeLine{642         \textcolor{keywordflow}{return} bridge\_point\_idx;}
\DoxyCodeLine{643     \}}
\DoxyCodeLine{644     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(max\_x<=med\_x)\{\textcolor{comment}{//the support line has point on left of med}}
\DoxyCodeLine{645         \textcolor{comment}{//So we could remove p from (p,q) whose slope is greater than}}
\DoxyCodeLine{646         \textcolor{comment}{//median slope, since mpq>mh>mb cuz on left.}}
\DoxyCodeLine{647         \textcolor{keywordtype}{int} leave\_flag=0;}
\DoxyCodeLine{648         \mbox{\hyperlink{classKirkpatrick__Seidel_ab93d5d2d8b237254490a31a48479489c}{generate\_new\_cand\_idx}}(leave\_flag,new\_cand\_idx,\(\backslash\)}
\DoxyCodeLine{649                                 pair\_slopes,LARGE\_SLOPE,\(\backslash\)}
\DoxyCodeLine{650                                 EQUAL\_SLOPE,SMALL\_SLOPE);}
\DoxyCodeLine{651     \}}
\DoxyCodeLine{652     \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{653         \textcolor{keywordtype}{int} leave\_flag=1;}
\DoxyCodeLine{654         \mbox{\hyperlink{classKirkpatrick__Seidel_ab93d5d2d8b237254490a31a48479489c}{generate\_new\_cand\_idx}}(leave\_flag,new\_cand\_idx,\(\backslash\)}
\DoxyCodeLine{655                                 pair\_slopes,LARGE\_SLOPE,\(\backslash\)}
\DoxyCodeLine{656                                 EQUAL\_SLOPE,SMALL\_SLOPE);}
\DoxyCodeLine{657     \}}
\DoxyCodeLine{658     \textcolor{keywordflow}{return} bridge\_point\_idx;}
\DoxyCodeLine{659 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a3469702d1b4f11eb2d52d8bd29a9f3a8}\label{classKirkpatrick__Seidel_a3469702d1b4f11eb2d52d8bd29a9f3a8}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!get\_candidates\_idx@{get\_candidates\_idx}}
\index{get\_candidates\_idx@{get\_candidates\_idx}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{get\_candidates\_idx()}{get\_candidates\_idx()}}
{\footnotesize\ttfamily vector$<$ int $>$ Kirkpatrick\+\_\+\+Seidel\+::get\+\_\+candidates\+\_\+idx (\begin{DoxyParamCaption}\item[{unsigned int}]{cur\+\_\+pu\+\_\+min\+\_\+idx,  }\item[{unsigned int}]{cur\+\_\+pu\+\_\+max\+\_\+idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This fucntion will give us the candidate points index on which we have to run the hull algorithm.

Idea\+: All the points which are above the min-\/max connecting line will be candidate (ie. greater min-\/point slope as compared to the min-\/max slope).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cur\+\_\+pu\+\_\+min\+\_\+idx} & \+: the minmum bound on the x-\/coordinate \\
\hline
\mbox{\texttt{ in}}  & {\em cur\+\_\+pu\+\_\+max\+\_\+idx} & \+: the maximum bound on the x-\/coordinate\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cand\+\_\+idx \+: the index of the candidate points relative to the points vector.
\end{DoxyReturn}


Definition at line 250 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{252                                                             \{}
\DoxyCodeLine{268     \textcolor{comment}{//calculating the min-\/max line slope}}
\DoxyCodeLine{269     \textcolor{keywordtype}{double} nx\_slope=\mbox{\hyperlink{classKirkpatrick__Seidel_a180f5fcebe4744b99ee618066b819764}{calculate\_p2p\_slope}}(cur\_pu\_min\_idx,}
\DoxyCodeLine{270                                         cur\_pu\_max\_idx);}
\DoxyCodeLine{271 }
\DoxyCodeLine{272     \textcolor{comment}{//Creating the cand-\/idx vector}}
\DoxyCodeLine{273     vector<int> cand\_idx;}
\DoxyCodeLine{274     \textcolor{comment}{//Pushing the min and max points}}
\DoxyCodeLine{275     cand\_idx.push\_back(cur\_pu\_min\_idx);}
\DoxyCodeLine{276     cand\_idx.push\_back(cur\_pu\_max\_idx);}
\DoxyCodeLine{277 }
\DoxyCodeLine{278     \textcolor{comment}{//Now traversing through points to get min-\/point line slope}}
\DoxyCodeLine{279     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<points.size();i++)\{}
\DoxyCodeLine{280         \textcolor{comment}{//Calculating the min-\/to-\/point line slope}}
\DoxyCodeLine{281         \textcolor{keywordflow}{if}(i==cur\_pu\_min\_idx || i==cur\_pu\_max\_idx)\{}
\DoxyCodeLine{282             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{283         \}}
\DoxyCodeLine{284         \textcolor{comment}{//Leaving the points who are outside this bound}}
\DoxyCodeLine{285         \textcolor{keywordflow}{if}(points[i].x>points[cur\_pu\_max\_idx].x ||}
\DoxyCodeLine{286                     points[i].x<points[cur\_pu\_min\_idx].x)\{}
\DoxyCodeLine{287             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{288         \}}
\DoxyCodeLine{289         \textcolor{keywordtype}{double} np\_slope=\mbox{\hyperlink{classKirkpatrick__Seidel_a180f5fcebe4744b99ee618066b819764}{calculate\_p2p\_slope}}(cur\_pu\_min\_idx,i);}
\DoxyCodeLine{290 }
\DoxyCodeLine{291         \textcolor{comment}{//Accepting or rejecting the points}}
\DoxyCodeLine{292         \textcolor{keywordflow}{if}(np\_slope>=nx\_slope)\{}
\DoxyCodeLine{293             cand\_idx.push\_back(i);}
\DoxyCodeLine{294         \}}
\DoxyCodeLine{295     \}}
\DoxyCodeLine{296 }
\DoxyCodeLine{297     \textcolor{keywordflow}{return} cand\_idx;}
\DoxyCodeLine{298 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a52003531d137b726b20e51ca614e40b7}\label{classKirkpatrick__Seidel_a52003531d137b726b20e51ca614e40b7}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!get\_extremum\_points@{get\_extremum\_points}}
\index{get\_extremum\_points@{get\_extremum\_points}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{get\_extremum\_points()}{get\_extremum\_points()}}
{\footnotesize\ttfamily void Kirkpatrick\+\_\+\+Seidel\+::get\+\_\+extremum\+\_\+points (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This function will find out the extreme point from the whole data points, which will serve as our one of the corners of upper\+\_\+min\+\_\+x, upper\+\_\+max\+\_\+x, lower\+\_\+min\+\_\+x, lower\+\_\+max\+\_\+x.

After finding the extreme points it will update their value in it\textquotesingle{}s member variable of this class.

Definition at line 174 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{174                                             \{}
\DoxyCodeLine{183     cout<<\textcolor{stringliteral}{"Finding the extremum points"}<<endl;}
\DoxyCodeLine{184     \textcolor{comment}{//Initializing the min and max value of x-\/coordinate of points}}
\DoxyCodeLine{185     \textcolor{keywordtype}{double} min\_x=INT\_MAX;}
\DoxyCodeLine{186     \textcolor{keywordtype}{double} max\_x=INT\_MIN;}
\DoxyCodeLine{187 }
\DoxyCodeLine{188     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<points.size();i++)\{}
\DoxyCodeLine{189         \textcolor{comment}{//Finding the minimum bound of the points}}
\DoxyCodeLine{190         \textcolor{keywordflow}{if}(points[i].x<min\_x)\{}
\DoxyCodeLine{191             \textcolor{comment}{//Updating the estimate of minumum x-\/coordinate}}
\DoxyCodeLine{192             min\_x=points[i].x;}
\DoxyCodeLine{193             \textcolor{comment}{//Updating the new minimum x-\/coordiante index}}
\DoxyCodeLine{194             pu\_min\_idx=i;}
\DoxyCodeLine{195             pl\_min\_idx=i;}
\DoxyCodeLine{196         \}}
\DoxyCodeLine{197         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(points[i].x==min\_x)\{}
\DoxyCodeLine{198             \textcolor{comment}{//if there are multiple points at same minumum x-\/coordinate}}
\DoxyCodeLine{199             \textcolor{keywordflow}{if}(points[pu\_min\_idx].y<points[i].y)\{}
\DoxyCodeLine{200                 \textcolor{comment}{//If the current point is above the pu\_min\_idx's y}}
\DoxyCodeLine{201                 pu\_min\_idx=i;}
\DoxyCodeLine{202             \}}
\DoxyCodeLine{203             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(points[pl\_min\_idx].y>points[i].y)\{}
\DoxyCodeLine{204                 \textcolor{comment}{//if the current point is even below pl\_min\_idx's y}}
\DoxyCodeLine{205                 pl\_min\_idx=i;}
\DoxyCodeLine{206             \}}
\DoxyCodeLine{207         \}}
\DoxyCodeLine{208 }
\DoxyCodeLine{209         \textcolor{comment}{//Finding the maximum bounds of the points}}
\DoxyCodeLine{210         \textcolor{keywordflow}{if}(points[i].x>max\_x)\{}
\DoxyCodeLine{211             \textcolor{comment}{//Updating the estimate of the maximum value}}
\DoxyCodeLine{212             max\_x=points[i].x;}
\DoxyCodeLine{213             \textcolor{comment}{//Changing the max-\/x coordinate index}}
\DoxyCodeLine{214             pu\_max\_idx=i;}
\DoxyCodeLine{215             pl\_max\_idx=i;}
\DoxyCodeLine{216         \}}
\DoxyCodeLine{217         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(points[i].x==max\_x)\{}
\DoxyCodeLine{218             \textcolor{comment}{//if two points are on the same x-\/coordinate farthest}}
\DoxyCodeLine{219             \textcolor{keywordflow}{if}(points[pu\_max\_idx].y<points[i].y)\{}
\DoxyCodeLine{220                 \textcolor{comment}{//if the upper max point is below the current point}}
\DoxyCodeLine{221                 pu\_max\_idx=i;}
\DoxyCodeLine{222             \}}
\DoxyCodeLine{223             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(points[pl\_max\_idx].y>points[i].y)\{}
\DoxyCodeLine{224                 \textcolor{comment}{//the the lower max point is above current point}}
\DoxyCodeLine{225                 pl\_max\_idx=i;}
\DoxyCodeLine{226             \}}
\DoxyCodeLine{227         \}}
\DoxyCodeLine{228     \}}
\DoxyCodeLine{229     \textcolor{comment}{//Printing the bounding points}}
\DoxyCodeLine{230     cout<<\textcolor{stringliteral}{"pu\_min\_"};\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(pu\_min\_idx);}
\DoxyCodeLine{231     cout<<\textcolor{stringliteral}{"pl\_min\_"};\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(pl\_min\_idx);}
\DoxyCodeLine{232     cout<<\textcolor{stringliteral}{"pu\_max\_"};\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(pu\_max\_idx);}
\DoxyCodeLine{233     cout<<\textcolor{stringliteral}{"pl\_max\_"};\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(pl\_max\_idx);cout<<endl;}
\DoxyCodeLine{234 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a489b1cbb1985e231f1ae41c7128adc1c}\label{classKirkpatrick__Seidel_a489b1cbb1985e231f1ae41c7128adc1c}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!get\_p2p\_slope\_entry@{get\_p2p\_slope\_entry}}
\index{get\_p2p\_slope\_entry@{get\_p2p\_slope\_entry}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{get\_p2p\_slope\_entry()}{get\_p2p\_slope\_entry()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structp2p__slope}{p2p\+\_\+slope}} $\ast$ Kirkpatrick\+\_\+\+Seidel\+::get\+\_\+p2p\+\_\+slope\+\_\+entry (\begin{DoxyParamCaption}\item[{int}]{idx1,  }\item[{int}]{idx2,  }\item[{double}]{slope }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This functio will dynamically allocate the struct and assign appropriate field and return the pointer to the struct.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em idx1} & \+: the index of the first point \\
\hline
\mbox{\texttt{ in}}  & {\em idx2} & \+: the index of the second point \\
\hline
\mbox{\texttt{ in}}  & {\em slope} & \+: the slope of line joint by these points\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
slope\+\_\+ptr\+: the pointer to the p2p struct element.
\end{DoxyReturn}


Definition at line 305 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{306                                                                   \{}
\DoxyCodeLine{317     \textcolor{comment}{//Dynamically allocating the strucut from ram's heap}}
\DoxyCodeLine{318     \textcolor{keyword}{struct }\mbox{\hyperlink{structp2p__slope}{p2p\_slope}} *slope\_ptr=(\textcolor{keyword}{struct }\mbox{\hyperlink{structp2p__slope}{p2p\_slope}}*)\(\backslash\)}
\DoxyCodeLine{319                                     malloc(\textcolor{keyword}{sizeof}(\mbox{\hyperlink{structp2p__slope}{p2p\_slope}}));}
\DoxyCodeLine{320 }
\DoxyCodeLine{321     \textcolor{comment}{//Assigning the value}}
\DoxyCodeLine{322     slope\_ptr-\/>idx1=idx1;}
\DoxyCodeLine{323     slope\_ptr-\/>idx2=idx2;}
\DoxyCodeLine{324     slope\_ptr-\/>slope=slope;}
\DoxyCodeLine{325 }
\DoxyCodeLine{326     \textcolor{keywordflow}{return} slope\_ptr;}
\DoxyCodeLine{327 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a403fd3696ad1a6b7dedb75cb8f5eaab7}\label{classKirkpatrick__Seidel_a403fd3696ad1a6b7dedb75cb8f5eaab7}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!get\_pair\_slopes@{get\_pair\_slopes}}
\index{get\_pair\_slopes@{get\_pair\_slopes}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{get\_pair\_slopes()}{get\_pair\_slopes()}}
{\footnotesize\ttfamily vector$<$ \mbox{\hyperlink{structp2p__slope}{p2p\+\_\+slope}} $\ast$ $>$ Kirkpatrick\+\_\+\+Seidel\+::get\+\_\+pair\+\_\+slopes (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{cand\+\_\+idx,  }\item[{vector$<$ int $>$ \&}]{new\+\_\+cand\+\_\+idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This is a utility function to be used by the upper bridge function to randomly pair up the point and calculate their corresponding slope.

In the process this will directly reject some of the points and put some of them directly into new candidate idx.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cand\+\_\+idx} & \+: the index of candidate points now. \\
\hline
\mbox{\texttt{ out}}  & {\em new\+\_\+cand\+\_\+idx} & the index of candidate points for next itr.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pair\+\_\+slopes \+: the pair of points with corresponding slope
\end{DoxyReturn}


Definition at line 329 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{331                                                               \{}
\DoxyCodeLine{345     \textcolor{comment}{//Initializing the p2p\_slope struct}}
\DoxyCodeLine{346     vector<struct p2p\_slope*> pair\_slopes;}
\DoxyCodeLine{347 }
\DoxyCodeLine{348     \textcolor{comment}{//Randomly pairing up the points (will do consecutive pairing)}}
\DoxyCodeLine{349     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<cand\_idx.size();i++)\{}
\DoxyCodeLine{350         \textcolor{keywordtype}{int} idx1=cand\_idx[i];i++;}
\DoxyCodeLine{351         \textcolor{comment}{//If we have odd number of points then dont pair it up}}
\DoxyCodeLine{352         \textcolor{keywordflow}{if}(i==cand\_idx.size())\{}
\DoxyCodeLine{353             new\_cand\_idx.push\_back(idx1);}
\DoxyCodeLine{354             \textcolor{keywordflow}{break};}
\DoxyCodeLine{355         \}}
\DoxyCodeLine{356         \textcolor{keywordtype}{int} idx2=cand\_idx[i];}
\DoxyCodeLine{357 }
\DoxyCodeLine{358         \textcolor{comment}{//Filtering the points if both the points lie on same x}}
\DoxyCodeLine{359         \textcolor{keywordflow}{if}(points[idx1].x==points[idx2].x)\{}
\DoxyCodeLine{360             \textcolor{keywordflow}{if}(points[idx1].y>points[idx2].y)\{}
\DoxyCodeLine{361                 cout<<\textcolor{stringliteral}{"point pair is verticle: removing: "}<<idx2;}
\DoxyCodeLine{362                 new\_cand\_idx.push\_back(idx1);}
\DoxyCodeLine{363             \}}
\DoxyCodeLine{364             \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{365                 cout<<\textcolor{stringliteral}{"point pair is verticle: removing: "}<<idx1;}
\DoxyCodeLine{366                 new\_cand\_idx.push\_back(idx2);}
\DoxyCodeLine{367             \}}
\DoxyCodeLine{368             cout<<endl;}
\DoxyCodeLine{369             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{370         \}}
\DoxyCodeLine{371 }
\DoxyCodeLine{372         \textcolor{comment}{//Calculating the point to point slope}}
\DoxyCodeLine{373         \textcolor{keywordtype}{double} slope=\mbox{\hyperlink{classKirkpatrick__Seidel_a180f5fcebe4744b99ee618066b819764}{calculate\_p2p\_slope}}(idx1,idx2);}
\DoxyCodeLine{374         \textcolor{comment}{//Printitng the pair and corresponding slope}}
\DoxyCodeLine{375         cout<<\textcolor{stringliteral}{"Pairing: "}<<idx1<<\textcolor{stringliteral}{" and "}<<idx2<<\textcolor{stringliteral}{" slope: "}<<slope;}
\DoxyCodeLine{376         cout<<endl;}
\DoxyCodeLine{377         \textcolor{comment}{//Adding the slope of point to the p2p\_slope vector}}
\DoxyCodeLine{378         \textcolor{keyword}{struct }\mbox{\hyperlink{structp2p__slope}{p2p\_slope}} *slope\_ptr=\mbox{\hyperlink{classKirkpatrick__Seidel_a489b1cbb1985e231f1ae41c7128adc1c}{get\_p2p\_slope\_entry}}(idx1,idx2,\(\backslash\)}
\DoxyCodeLine{379                                                         slope);}
\DoxyCodeLine{380         pair\_slopes.push\_back(slope\_ptr);}
\DoxyCodeLine{381     \}}
\DoxyCodeLine{382 }
\DoxyCodeLine{383     \textcolor{keywordflow}{return} pair\_slopes;}
\DoxyCodeLine{384 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a5186a9dd5060b8243cf455c7faf9fb92}\label{classKirkpatrick__Seidel_a5186a9dd5060b8243cf455c7faf9fb92}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!get\_upper\_bridge@{get\_upper\_bridge}}
\index{get\_upper\_bridge@{get\_upper\_bridge}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{get\_upper\_bridge()}{get\_upper\_bridge()}}
{\footnotesize\ttfamily vector$<$ int $>$ Kirkpatrick\+\_\+\+Seidel\+::get\+\_\+upper\+\_\+bridge (\begin{DoxyParamCaption}\item[{double}]{med\+\_\+x,  }\item[{vector$<$ int $>$ \&}]{cand\+\_\+idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This function will give the pair of points which forms a bridge in candidate points,covering our head from above. This bridge will merge the two sub-\/problem split before.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em median\+\_\+x} & \+: the x-\/coordinate of the median point. \\
\hline
\mbox{\texttt{ in}}  & {\em cand\+\_\+idx} & \+: the index of points on which to get bridge.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bridge\+\_\+point\+\_\+idx \+: the index in sorted order acc to x-\/coordinate formning the bridge above. (it could be only 2 point)
\end{DoxyReturn}


Definition at line 661 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{662                                                                   \{}
\DoxyCodeLine{675     \textcolor{comment}{//Initializing the bridge vector}}
\DoxyCodeLine{676     vector<int> bridge\_point\_idx;}
\DoxyCodeLine{677 }
\DoxyCodeLine{678     \textcolor{comment}{//Now getting the bridges from the set of upper points}}
\DoxyCodeLine{679     \textcolor{keywordflow}{while}(bridge\_point\_idx.size()!=2)\{}
\DoxyCodeLine{680         \textcolor{comment}{//Handling the base case when only two points are in candidate}}
\DoxyCodeLine{681         \textcolor{keywordflow}{if}(cand\_idx.size()==2)\{}
\DoxyCodeLine{682             \textcolor{keywordflow}{if}(points[cand\_idx[0]].x<points[cand\_idx[1]].x)\{}
\DoxyCodeLine{683                 bridge\_point\_idx.push\_back(cand\_idx[0]);}
\DoxyCodeLine{684                 bridge\_point\_idx.push\_back(cand\_idx[1]);}
\DoxyCodeLine{685             \}}
\DoxyCodeLine{686             \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{687                 bridge\_point\_idx.push\_back(cand\_idx[1]);}
\DoxyCodeLine{688                 bridge\_point\_idx.push\_back(cand\_idx[0]);}
\DoxyCodeLine{689             \}}
\DoxyCodeLine{690             \textcolor{keywordflow}{return} bridge\_point\_idx;}
\DoxyCodeLine{691         \}}
\DoxyCodeLine{692 }
\DoxyCodeLine{693         \textcolor{comment}{//Calculating the slopes}}
\DoxyCodeLine{694         \textcolor{comment}{//Initializing the vector for the next set of candidaates idx}}
\DoxyCodeLine{695         vector<int> new\_cand\_idx;}
\DoxyCodeLine{696         vector<struct p2p\_slope*> pair\_slopes;}
\DoxyCodeLine{697         \textcolor{comment}{//Calculating the sloped of the points along with some new cand}}
\DoxyCodeLine{698         cout<<\textcolor{stringliteral}{"\(\backslash\)nPairing points and calculating slopes\(\backslash\)n"};}
\DoxyCodeLine{699         pair\_slopes=\mbox{\hyperlink{classKirkpatrick__Seidel_a403fd3696ad1a6b7dedb75cb8f5eaab7}{get\_pair\_slopes}}(cand\_idx,new\_cand\_idx);}
\DoxyCodeLine{700         \textcolor{comment}{//Handling the case when number of no pair of points are formed}}
\DoxyCodeLine{701         \textcolor{keywordflow}{if}(pair\_slopes.size()==0)\{}
\DoxyCodeLine{702             \textcolor{comment}{//Reinitializing the new candidate indexes as curr candidate}}
\DoxyCodeLine{703             cand\_idx.assign(new\_cand\_idx.begin(),new\_cand\_idx.end());}
\DoxyCodeLine{704             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{705         \}}
\DoxyCodeLine{706         \textcolor{comment}{//Have to free up the p2p\_slope pointers from heap}}
\DoxyCodeLine{707 }
\DoxyCodeLine{708         \textcolor{comment}{//Calcualting the median slopes index and making 3 slope buckets}}
\DoxyCodeLine{709         vector<int> LARGE\_SLOPE;}
\DoxyCodeLine{710         vector<int> EQUAL\_SLOPE;}
\DoxyCodeLine{711         vector<int> SMALL\_SLOPE;}
\DoxyCodeLine{712         \textcolor{comment}{//Calulating the median slope}}
\DoxyCodeLine{713         \textcolor{keywordtype}{int} med\_slope\_idx=fill\_slope\_bucket(pair\_slopes,LARGE\_SLOPE,\(\backslash\)}
\DoxyCodeLine{714                                             EQUAL\_SLOPE,SMALL\_SLOPE);}
\DoxyCodeLine{715 }
\DoxyCodeLine{716         \textcolor{comment}{//Now finding the new candidate indexes or the the bridge points}}
\DoxyCodeLine{717         bridge\_point\_idx=\mbox{\hyperlink{classKirkpatrick__Seidel_a88715575474aaae15641eb578e94933d}{get\_bridge\_or\_candidate}}(med\_x,med\_slope\_idx,\(\backslash\)}
\DoxyCodeLine{718                                             cand\_idx,new\_cand\_idx,\(\backslash\)}
\DoxyCodeLine{719                                             pair\_slopes,LARGE\_SLOPE,\(\backslash\)}
\DoxyCodeLine{720                                             EQUAL\_SLOPE,SMALL\_SLOPE);}
\DoxyCodeLine{721 }
\DoxyCodeLine{722         \textcolor{comment}{//Reinitializing the new candidate indexes as curr candidate}}
\DoxyCodeLine{723         cand\_idx.assign(new\_cand\_idx.begin(),new\_cand\_idx.end());}
\DoxyCodeLine{724         \textcolor{comment}{//Freeing up the point pairs}}
\DoxyCodeLine{725         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<pair\_slopes.size();i++)\{}
\DoxyCodeLine{726             free(pair\_slopes[i]);}
\DoxyCodeLine{727         \}}
\DoxyCodeLine{728         cout<<\textcolor{stringliteral}{"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#"}<<endl;}
\DoxyCodeLine{729         cout<<\textcolor{stringliteral}{"AN ITERATION OF UPPER BRIDGE DONE"}<<endl;}
\DoxyCodeLine{730         cout<<\textcolor{stringliteral}{"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#"}<<endl<<endl;}
\DoxyCodeLine{731     \}}
\DoxyCodeLine{732     \textcolor{keywordflow}{return} bridge\_point\_idx;}
\DoxyCodeLine{733 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a354a7cd71efe24b6750744b993ad48f5}\label{classKirkpatrick__Seidel_a354a7cd71efe24b6750744b993ad48f5}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!get\_upper\_hull@{get\_upper\_hull}}
\index{get\_upper\_hull@{get\_upper\_hull}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{get\_upper\_hull()}{get\_upper\_hull()}}
{\footnotesize\ttfamily void Kirkpatrick\+\_\+\+Seidel\+::get\+\_\+upper\+\_\+hull (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{cand\+\_\+idx,  }\item[{unsigned int}]{min\+\_\+x\+\_\+idx,  }\item[{unsigned int}]{max\+\_\+x\+\_\+idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This function will generate the upper hull of from the given set of living points. This function will recursively call itself each time it partition the problem into two half and joining them by finding the upper bridge.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cand\+\_\+idx} & \+: a.\+dtype = vector$<$int$>$ b. the points on which to run the upper hull algorithm.(candidates) \\
\hline
\mbox{\texttt{ in}}  & {\em min\+\_\+x\+\_\+idx} & \+: the index of the lower bound of x-\/coord \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+x\+\_\+idx} & \+: the index of the upper bound of x-\/coord for this current problem.\\
\hline
\end{DoxyParams}


Definition at line 767 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{769                                                \{}
\DoxyCodeLine{783     \textcolor{comment}{//Handling the base case here itself, otherwise infinite loop}}
\DoxyCodeLine{784     \textcolor{keywordflow}{if}(cand\_idx.size()==2)\{}
\DoxyCodeLine{785         cout<<\textcolor{stringliteral}{"Base case reached for the bridge\(\backslash\)n"}<<endl;}
\DoxyCodeLine{786         \textcolor{comment}{//Directly appending the points to the final hull}}
\DoxyCodeLine{787         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_ad4364483a9ba0f48498d010ff7b16590}{append\_bridge\_point\_to\_hull}}(cand\_idx);}
\DoxyCodeLine{788         \textcolor{keywordflow}{return};}
\DoxyCodeLine{789     \}}
\DoxyCodeLine{790 }
\DoxyCodeLine{791 }
\DoxyCodeLine{792     \textcolor{comment}{/*         MERGING STEP OF DIVIDE AND CONQUER          */}}
\DoxyCodeLine{793     \textcolor{comment}{//Finding the median element among the live candidate ones}}
\DoxyCodeLine{794     cout<<\textcolor{stringliteral}{"Finding the median x coordinate"}<<endl;}
\DoxyCodeLine{795     \textcolor{keywordtype}{int} med\_idx=calculate\_median(cand\_idx,this-\/>points);}
\DoxyCodeLine{796     \textcolor{keywordtype}{double} median\_x=points[med\_idx].x;}
\DoxyCodeLine{797     cout<<\textcolor{stringliteral}{"Median Index is: "}<<med\_idx<<\textcolor{stringliteral}{" at x-\/coord: "}<<median\_x;}
\DoxyCodeLine{798     cout<<endl;}
\DoxyCodeLine{799 }
\DoxyCodeLine{800     \textcolor{comment}{//Now we have to calculate the upper bridge}}
\DoxyCodeLine{801     vector<int> bridge\_point\_idx;}
\DoxyCodeLine{802     bridge\_point\_idx=\mbox{\hyperlink{classKirkpatrick__Seidel_a5186a9dd5060b8243cf455c7faf9fb92}{get\_upper\_bridge}}(median\_x,cand\_idx);}
\DoxyCodeLine{803     \textcolor{comment}{//Appending the point to the final hull index list}}
\DoxyCodeLine{804     this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_ad4364483a9ba0f48498d010ff7b16590}{append\_bridge\_point\_to\_hull}}(bridge\_point\_idx);}
\DoxyCodeLine{805 }
\DoxyCodeLine{806 }
\DoxyCodeLine{807     \textcolor{comment}{/*       DIVISION STEP OF DIVIDE AND CONQUER             */}}
\DoxyCodeLine{808 }
\DoxyCodeLine{809     \textcolor{comment}{//SOLVING LEFT SUB-\/PROBLEM}}
\DoxyCodeLine{810     \textcolor{comment}{//Calculating the new candidate for the left sub problem}}
\DoxyCodeLine{811     vector<int> left\_cand\_idx;}
\DoxyCodeLine{812     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} left\_pu\_max\_idx=bridge\_point\_idx[0];}
\DoxyCodeLine{813     cout<<\textcolor{stringliteral}{"\(\backslash\)nSolving the left sub-\/problem"}<<endl;}
\DoxyCodeLine{814     cout<<\textcolor{stringliteral}{"left\_min\_idx: "}<<min\_x\_idx<<endl;}
\DoxyCodeLine{815     cout<<\textcolor{stringliteral}{"left\_max\_idx: "}<<left\_pu\_max\_idx<<endl;}
\DoxyCodeLine{816     \textcolor{keywordflow}{if}(min\_x\_idx!=left\_pu\_max\_idx)\{}
\DoxyCodeLine{817         \textcolor{comment}{//Getting the index of probable point on left bridge}}
\DoxyCodeLine{818         \textcolor{comment}{//bool upside=true;}}
\DoxyCodeLine{819         left\_cand\_idx=this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_a3469702d1b4f11eb2d52d8bd29a9f3a8}{get\_candidates\_idx}}(min\_x\_idx,\(\backslash\)}
\DoxyCodeLine{820                                                 left\_pu\_max\_idx);}
\DoxyCodeLine{821         \textcolor{comment}{//Printing the candidate indexes}}
\DoxyCodeLine{822         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<left\_cand\_idx.size();i++)\{}
\DoxyCodeLine{823             cout<<\textcolor{stringliteral}{"UH-\/Cand: "};}
\DoxyCodeLine{824             this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(left\_cand\_idx[i]);}
\DoxyCodeLine{825         \}}
\DoxyCodeLine{826         \textcolor{comment}{//Calling this function recursively to solve left part}}
\DoxyCodeLine{827         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_a354a7cd71efe24b6750744b993ad48f5}{get\_upper\_hull}}(left\_cand\_idx,min\_x\_idx,\(\backslash\)}
\DoxyCodeLine{828                                             left\_pu\_max\_idx);}
\DoxyCodeLine{829     \}}
\DoxyCodeLine{830 }
\DoxyCodeLine{831     \textcolor{comment}{//SOLVING RIGHT SUB-\/PROBLEM}}
\DoxyCodeLine{832     \textcolor{comment}{//Calculating the new candidates for right side}}
\DoxyCodeLine{833     vector<int> right\_cand\_idx;}
\DoxyCodeLine{834     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} right\_pu\_min\_idx=bridge\_point\_idx[1];}
\DoxyCodeLine{835     cout<<\textcolor{stringliteral}{"\(\backslash\)n\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\(\backslash\)n"};}
\DoxyCodeLine{836     cout<<\textcolor{stringliteral}{"Solving the right sub-\/problem"}<<endl;}
\DoxyCodeLine{837     cout<<\textcolor{stringliteral}{"right\_min\_idx: "}<<right\_pu\_min\_idx<<endl;}
\DoxyCodeLine{838     cout<<\textcolor{stringliteral}{"right\_max\_idx: "}<<max\_x\_idx<<endl;}
\DoxyCodeLine{839     \textcolor{keywordflow}{if}(right\_pu\_min\_idx!=max\_x\_idx)\{}
\DoxyCodeLine{840         \textcolor{comment}{//Getting the new candidates for the right side}}
\DoxyCodeLine{841         \textcolor{comment}{//bool upside=true;}}
\DoxyCodeLine{842         right\_cand\_idx=this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_a3469702d1b4f11eb2d52d8bd29a9f3a8}{get\_candidates\_idx}}(right\_pu\_min\_idx,\(\backslash\)}
\DoxyCodeLine{843                                                 max\_x\_idx);}
\DoxyCodeLine{844         \textcolor{comment}{//Printing the candidate indexes}}
\DoxyCodeLine{845         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<right\_cand\_idx.size();i++)\{}
\DoxyCodeLine{846             cout<<\textcolor{stringliteral}{"UH-\/Cand: "};}
\DoxyCodeLine{847             this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(right\_cand\_idx[i]);}
\DoxyCodeLine{848         \}}
\DoxyCodeLine{849         \textcolor{comment}{//Calling this function recursively to solve right side}}
\DoxyCodeLine{850         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_a354a7cd71efe24b6750744b993ad48f5}{get\_upper\_hull}}(right\_cand\_idx,right\_pu\_min\_idx,\(\backslash\)}
\DoxyCodeLine{851                                             max\_x\_idx);}
\DoxyCodeLine{852     \}}
\DoxyCodeLine{853     \textcolor{keywordflow}{return};}
\DoxyCodeLine{854 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a27411b5aba77fbca38854e6032c2ac33}\label{classKirkpatrick__Seidel_a27411b5aba77fbca38854e6032c2ac33}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!print\_pairs\_on\_hull@{print\_pairs\_on\_hull}}
\index{print\_pairs\_on\_hull@{print\_pairs\_on\_hull}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{print\_pairs\_on\_hull()}{print\_pairs\_on\_hull()}}
{\footnotesize\ttfamily void Kirkpatrick\+\_\+\+Seidel\+::print\+\_\+pairs\+\_\+on\+\_\+hull (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

This function will allow the outside world to print the pair of points on the hull.

Definition at line 26 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{26                                             \{}
\DoxyCodeLine{31     cout<<\textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\(\backslash\)n"};}
\DoxyCodeLine{32     cout<<\textcolor{stringliteral}{"Printing the pair of point on the convex hull\(\backslash\)n"};}
\DoxyCodeLine{33     cout<<\textcolor{stringliteral}{"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\(\backslash\)n"};}
\DoxyCodeLine{34     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<hull\_point\_pairs.size();i++)\{}
\DoxyCodeLine{35         pair<int,int> hull\_pair=hull\_point\_pairs[i];}
\DoxyCodeLine{36         cout<<\textcolor{stringliteral}{"HULL PAIR:\(\backslash\)n"};}
\DoxyCodeLine{37         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(hull\_pair.first);}
\DoxyCodeLine{38         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(hull\_pair.second);}
\DoxyCodeLine{39         cout<<endl;}
\DoxyCodeLine{40     \}}
\DoxyCodeLine{41 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}\label{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!print\_point@{print\_point}}
\index{print\_point@{print\_point}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{print\_point()}{print\_point()}}
{\footnotesize\ttfamily void Kirkpatrick\+\_\+\+Seidel\+::print\+\_\+point (\begin{DoxyParamCaption}\item[{int}]{idx }\end{DoxyParamCaption})}

This function will be used to print the points given it\textquotesingle{}s index easily without needing to access the points vector everytime in properly formatted order.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em idx} & the index of the point in the point vector\\
\hline
\end{DoxyParams}


Definition at line 13 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13                                            \{}
\DoxyCodeLine{21     cout<<\textcolor{stringliteral}{"idx:"}<<idx<<\textcolor{stringliteral}{" at location: "};}
\DoxyCodeLine{22     cout<<points[idx].x<<\textcolor{stringliteral}{","}<<points[idx].y<<endl;}
\DoxyCodeLine{23 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a87772fab208930356384e5c568ecee69}\label{classKirkpatrick__Seidel_a87772fab208930356384e5c568ecee69}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!put\_a\_hull\_on\_points@{put\_a\_hull\_on\_points}}
\index{put\_a\_hull\_on\_points@{put\_a\_hull\_on\_points}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{put\_a\_hull\_on\_points()}{put\_a\_hull\_on\_points()}}
{\footnotesize\ttfamily void Kirkpatrick\+\_\+\+Seidel\+::put\+\_\+a\+\_\+hull\+\_\+on\+\_\+points (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

This function is the main iterface of talking for finding the convex world from the outside world.\+Internally it will call it\textquotesingle{}s helper function to generate the convex hull and put the indexes of the points in the member variable hull\+\_\+point\+\_\+pairs

Definition at line 44 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{44                                              \{}
\DoxyCodeLine{52         \textcolor{comment}{/*                 UPPER HULL GENERATION                    */}}
\DoxyCodeLine{55         \textcolor{comment}{//Generating the candidate points which could form upper hull.}}
\DoxyCodeLine{56         cout<<\textcolor{stringliteral}{"////////////////////////////////////\(\backslash\)n"};}
\DoxyCodeLine{57         cout<<\textcolor{stringliteral}{"Generating the UPPER-\/HULL Candidates"}<<endl;}
\DoxyCodeLine{58         cout<<\textcolor{stringliteral}{"////////////////////////////////////\(\backslash\)n"};}
\DoxyCodeLine{59         \textcolor{comment}{//bool upside=true;}}
\DoxyCodeLine{60         vector<int> cand\_idx=\mbox{\hyperlink{classKirkpatrick__Seidel_a3469702d1b4f11eb2d52d8bd29a9f3a8}{get\_candidates\_idx}}(this-\/>pu\_min\_idx,\(\backslash\)}
\DoxyCodeLine{61                                                 this-\/>pu\_max\_idx);}
\DoxyCodeLine{62         \textcolor{comment}{//Printing the candidate indexes}}
\DoxyCodeLine{63         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<cand\_idx.size();i++)\{}
\DoxyCodeLine{64             cout<<\textcolor{stringliteral}{"UH-\/Cand: "};}
\DoxyCodeLine{65             this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(cand\_idx[i]);}
\DoxyCodeLine{66         \}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68         \textcolor{comment}{//Now calling the upper hull creator to get upper hull}}
\DoxyCodeLine{69         cout<<endl<<\textcolor{stringliteral}{"Calling the Upper Hull function"}<<endl;}
\DoxyCodeLine{70         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_a354a7cd71efe24b6750744b993ad48f5}{get\_upper\_hull}}(cand\_idx,this-\/>pu\_min\_idx,\(\backslash\)}
\DoxyCodeLine{71                                         this-\/>pu\_max\_idx);}
\DoxyCodeLine{72 }
\DoxyCodeLine{73         \textcolor{comment}{//Printing the upper hull index}}
\DoxyCodeLine{74         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_a27411b5aba77fbca38854e6032c2ac33}{print\_pairs\_on\_hull}}();}
\DoxyCodeLine{75 }
\DoxyCodeLine{77         \textcolor{comment}{/*              LOWER HULL GENERATION                       */}}
\DoxyCodeLine{79         \textcolor{comment}{//generate the candidates for the lower hull}}
\DoxyCodeLine{80         cout<<endl<<endl;}
\DoxyCodeLine{81         cout<<\textcolor{stringliteral}{"////////////////////////////////////\(\backslash\)n"};}
\DoxyCodeLine{82         cout<<\textcolor{stringliteral}{"Generating the LOWER-\/HULL candidates"}<<endl;}
\DoxyCodeLine{83         cout<<\textcolor{stringliteral}{"////////////////////////////////////\(\backslash\)n"};}
\DoxyCodeLine{84 }
\DoxyCodeLine{85         \textcolor{comment}{//Now we will hack our system to generate use model}}
\DoxyCodeLine{86         \textcolor{comment}{//lower hull probelm to upper hull problem.}}
\DoxyCodeLine{87         cout<<\textcolor{stringliteral}{"Hacking the lower hull as upper hull\(\backslash\)n"};}
\DoxyCodeLine{88         \mbox{\hyperlink{classKirkpatrick__Seidel_a766a0a811f34a933a6c53125df5ee1d7}{transform\_lowers\_to\_upper}}();}
\DoxyCodeLine{89 }
\DoxyCodeLine{90         \textcolor{comment}{//Resetting our upside flag to represent we want lower hull cand}}
\DoxyCodeLine{91         \textcolor{comment}{//upside=false;}}
\DoxyCodeLine{92         cand\_idx.clear();}
\DoxyCodeLine{93         cand\_idx=\mbox{\hyperlink{classKirkpatrick__Seidel_a3469702d1b4f11eb2d52d8bd29a9f3a8}{get\_candidates\_idx}}(this-\/>pl\_min\_idx,this-\/>pl\_max\_idx);}
\DoxyCodeLine{94         \textcolor{comment}{//Printing the index of candidate}}
\DoxyCodeLine{95         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<cand\_idx.size();i++)\{}
\DoxyCodeLine{96             cout<<\textcolor{stringliteral}{"LH-\/Cand: "};}
\DoxyCodeLine{97             this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_ac2608acfdf7d7194a23f1727d071a9cb}{print\_point}}(cand\_idx[i]);}
\DoxyCodeLine{98         \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100         \textcolor{comment}{//Calling the upper hull function on this hacked points}}
\DoxyCodeLine{101         cout<<\textcolor{stringliteral}{"Calling the upper hull function on hacked points"}<<endl;}
\DoxyCodeLine{102         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_a354a7cd71efe24b6750744b993ad48f5}{get\_upper\_hull}}(cand\_idx,}
\DoxyCodeLine{103                                 this-\/>pl\_min\_idx,}
\DoxyCodeLine{104                                 this-\/>pl\_max\_idx);}
\DoxyCodeLine{105 }
\DoxyCodeLine{106         \textcolor{comment}{//Correcting the hacking done in the points (calling same func)}}
\DoxyCodeLine{107         \mbox{\hyperlink{classKirkpatrick__Seidel_a766a0a811f34a933a6c53125df5ee1d7}{transform\_lowers\_to\_upper}}();}
\DoxyCodeLine{108 }
\DoxyCodeLine{110         \textcolor{comment}{/*            JOINING UPPER AND LOWER HULL                */}}
\DoxyCodeLine{112         \textcolor{comment}{//Adding the pl and pu points to the hull also if they are diff}}
\DoxyCodeLine{113         \textcolor{comment}{//Joining the left side of upper hull to lower hull.}}
\DoxyCodeLine{114         \textcolor{keywordflow}{if}(this-\/>pu\_min\_idx!=this-\/>pl\_min\_idx)\{}
\DoxyCodeLine{115             \textcolor{comment}{//Making a pair of point to join the upper hull to lower}}
\DoxyCodeLine{116             pair<int,int> hull\_pair;}
\DoxyCodeLine{117             hull\_pair=make\_pair(this-\/>pl\_min\_idx,this-\/>pu\_min\_idx);}
\DoxyCodeLine{118             \textcolor{comment}{//Adding this pair to the hull pair vector}}
\DoxyCodeLine{119             this-\/>hull\_point\_pairs.push\_back(hull\_pair);}
\DoxyCodeLine{120         \}}
\DoxyCodeLine{121         \textcolor{comment}{//Sewing the right side of upper hull to lower hull}}
\DoxyCodeLine{122         \textcolor{keywordflow}{if}(this-\/>pu\_max\_idx!=this-\/>pl\_max\_idx)\{}
\DoxyCodeLine{123             \textcolor{comment}{//Joing the upper and lower hull}}
\DoxyCodeLine{124             pair<int,int> hull\_pair;}
\DoxyCodeLine{125             hull\_pair=make\_pair(this-\/>pl\_max\_idx,this-\/>pu\_max\_idx);}
\DoxyCodeLine{126             \textcolor{comment}{//Adding this pair to upper hull}}
\DoxyCodeLine{127             this-\/>hull\_point\_pairs.push\_back(hull\_pair);}
\DoxyCodeLine{128         \}}
\DoxyCodeLine{129 }
\DoxyCodeLine{130         \textcolor{comment}{//Finally printing all the pair of points on hull}}
\DoxyCodeLine{131         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_a27411b5aba77fbca38854e6032c2ac33}{print\_pairs\_on\_hull}}();}
\DoxyCodeLine{132 }
\DoxyCodeLine{133         \textcolor{comment}{//Drwaing the bridge on the gui}}
\DoxyCodeLine{134         this-\/>\mbox{\hyperlink{classKirkpatrick__Seidel_a3580c52f1f0cf27589ce8fa39f7af669}{draw\_bridge}}();}
\DoxyCodeLine{135     \}}

\end{DoxyCode}
\mbox{\Hypertarget{classKirkpatrick__Seidel_a766a0a811f34a933a6c53125df5ee1d7}\label{classKirkpatrick__Seidel_a766a0a811f34a933a6c53125df5ee1d7}} 
\index{Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}!transform\_lowers\_to\_upper@{transform\_lowers\_to\_upper}}
\index{transform\_lowers\_to\_upper@{transform\_lowers\_to\_upper}!Kirkpatrick\_Seidel@{Kirkpatrick\_Seidel}}
\doxysubsubsection{\texorpdfstring{transform\_lowers\_to\_upper()}{transform\_lowers\_to\_upper()}}
{\footnotesize\ttfamily void Kirkpatrick\+\_\+\+Seidel\+::transform\+\_\+lowers\+\_\+to\+\_\+upper (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

This function will reflect the points on the lower side of convex hull above the pl\+\_\+min and pl\+\_\+max line, and then solve the problem using upper convex hull.

But in the process we will modify the index of actual point coordinate so we will temporatrily keep a correct copy of points and correct it later.

Definition at line 861 of file kirkpatrick\+\_\+seidel.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{861                                                   \{}
\DoxyCodeLine{871     \textcolor{comment}{//Now we have to reflect the coordinate of candidates about}}
\DoxyCodeLine{872     \textcolor{comment}{//the pl\_min and pl\_max line. It's enough to reflect around}}
\DoxyCodeLine{873     \textcolor{comment}{//x-\/axis.}}
\DoxyCodeLine{874     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<points.size();i++)\{}
\DoxyCodeLine{875         \textcolor{comment}{//Reflecting the candidate points about x-\/axis}}
\DoxyCodeLine{876         points[i].y=(-\/1*points[i].y);}
\DoxyCodeLine{877         \textcolor{comment}{//There are no chages in the x-\/coordinate of the cand}}
\DoxyCodeLine{878     \}}
\DoxyCodeLine{879 \}}

\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
kirkpatrick\+\_\+seidel.\+h\item 
kirkpatrick\+\_\+seidel.\+cpp\end{DoxyCompactItemize}
